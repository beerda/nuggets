#pragma once

#include <vector>
#include <unordered_map>

#include "../common.h"


class TautologyTree {
public:
    /**
     * Represents a node in the tautology tree.
     */
    struct Node {
        Node(size_t childrenSize)
            : children(childrenSize, nullptr)
        { }

        ~Node()
        {
            for (Node* child : children) {
                delete child;
            }
        }

        size_t nChildren() const
        {
            size_t result = 0;
            for (Node* child : children) {
                if (child != nullptr)
                    result++;
            }

            return result;
        }

        void storeConsequentsTo(vector<int>& vec) const
        { vec.insert(vec.end(), consequents.begin(), consequents.end()); }

        vector<Node*> children;
        vector<int> consequents;
    };


    /**
     * Constructs a new tautology tree with allowed predicates in antecedents.
     *
     * @param antecedents The vector of antecedent predicates in the order they will be
     *     enumerated by the condition generating algorithm.
     */
    TautologyTree(vector<int> antecedents)
        : root(antecedents.size()),
          predicateToIndex(*max_element(antecedents.begin(), antecedents.end()) + 1, -1)
    {
        for (size_t i = 0; i < antecedents.size(); ++i) {
            predicateToIndex[antecedents[i]] = i;
        }
    }

    /**
     * Adds a tautology to the tree. The antecedent may be unsorted.
     *
     * @param antecedent The antecedent predicates. (May be unsorted.)
     * @param consequent The consequent predicate.
     */
    void addTautology(const vector<int>& antecedent, const int consequent)
    {
        vector<int> sortedAntecedent(antecedent);
        sortAntecedent(sortedAntecedent);
        put(&root, sortedAntecedent.rbegin(), sortedAntecedent.rend(), consequent);
    }

    /**
     * Returns the root node of the tree.
     */
    const Node* getRoot() const
    { return &root; }

    /**
     * Deduces consequents for the antecedent given by the prefix and current predicate.
     * The prefix is expected to be sorted in the reverse order to the order of antecedents.
     * (I.e. in the order as generated by the condition generating algorithm.)
     *
     * @param prefix The prefix part of the antecedent, sorted in the reverse order.
     * @param predicate The current predicate.
     * @return The vector of consequents.
     */
    vector<int> deduceConsequentsByRevSorted(const vector<int>& prefix, int predicate) const
    {
        vector<int> result;
        root.storeConsequentsTo(result);
        const Node* node = root.children[predicateToIndex[predicate]];
        if (node != nullptr) {
            get(node, prefix.begin(), prefix.end(), result);
        }

        return result;
    }

private:
    Node root;
    vector<size_t> predicateToIndex; // mapping of predicate -> index

    void sortAntecedent(vector<int>& antecedent)
    {
        sort(antecedent.begin(), antecedent.end(), [&](int a, int b) {
            return predicateToIndex[a] < predicateToIndex[b];
        });
    }

    template <typename Iterator>
    void put(Node* node, Iterator b, Iterator e, const int consequent)
    {
        if (b == e) {
            node->consequents.push_back(consequent);
        }
        else {
            int predicate = *b;
            size_t index = predicateToIndex[predicate];
            if (node->children[index] == nullptr) {
                node->children[index] = new Node(index);
            }
            put(node->children[index], b + 1, e, consequent);
        }
    }

    template <typename Iterator>
    void get(const Node* node, Iterator b, Iterator e, vector<int>& result) const
    {
        node->storeConsequentsTo(result);
        while (b != e) {
            int predicate = *b;
            size_t index = predicateToIndex[predicate];
            Node* child = node->children[index];
            if (child != nullptr) {
                get(child, b + 1, e, result);
            }
            b++;
        }
    }
};

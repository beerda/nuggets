% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partition.R
\name{partition}
\alias{partition}
\title{Convert columns of a data frame to Boolean or fuzzy sets
(triangular, trapezoidal, or raised-cosine)}
\usage{
partition(
  .data,
  .what = everything(),
  ...,
  .breaks = NULL,
  .labels = NULL,
  .na = TRUE,
  .keep = FALSE,
  .method = "crisp",
  .right = TRUE,
  .span = 1,
  .inc = 1
)
}
\arguments{
\item{.data}{A data frame to be processed.}

\item{.what}{A tidyselect expression (see
\href{https://tidyselect.r-lib.org/articles/syntax.html}{tidyselect syntax})
selecting the columns to transform.}

\item{...}{Additional tidyselect expressions selecting more columns.}

\item{.breaks}{Ignored if \code{.method = "dummy"}. For other methods, either
an integer scalar (number of intervals/sets) or a numeric vector of
breakpoints.}

\item{.labels}{Optional character vector with labels used for new column
names. If \code{NULL}, labels are generated automatically.}

\item{.na}{If \code{TRUE}, an extra logical column is created for each source
column that contains \code{NA} values (e.g. \code{x=NA}).}

\item{.keep}{If \code{TRUE}, keep the original columns in the output.}

\item{.method}{Transformation method for numeric columns: \code{"dummy"},
\code{"crisp"}, \code{"triangle"}, or \code{"raisedcos"}.}

\item{.right}{For \code{"crisp"}, whether intervals are right-closed and
left-open (\code{TRUE}), or left-closed and right-open (\code{FALSE}).}

\item{.span}{Number of consecutive breaks forming a set. For \code{"crisp"},
controls interval width. For \code{"triangle"}/\code{"raisedcos"}, \code{.span = 1}
produces triangular sets, \code{.span = 2} trapezoidal sets.}

\item{.inc}{Step size for shifting breaks when generating successive sets.
With \code{.inc = 1}, all possible sets are created; larger values skip sets.}
}
\value{
A tibble with \code{.data} transformed into Boolean or fuzzy predicates.
}
\description{
Transform selected columns of a data frame into either dummy logical
variables or membership degrees of fuzzy sets, while leaving all remaining
columns unchanged. Each transformed column typically produces multiple new
columns in the output.
}
\details{
These transformations are most often used as a preprocessing step before
calling \code{\link[=dig]{dig()}} or one of its derivatives, such as
\code{\link[=dig_correlations]{dig_correlations()}}, \code{\link[=dig_paired_baseline_contrasts]{dig_paired_baseline_contrasts()}},
or \code{\link[=dig_associations]{dig_associations()}}.

The transformation depends on the column type:
\itemize{
\item \strong{logical} column \code{x} is expanded into two logical columns:
\code{x=TRUE} and \code{x=FALSE};
\item \strong{factor} column \code{x} with levels \code{l1}, \code{l2}, \code{l3} becomes three
logical columns: \code{x=l1}, \code{x=l2}, and \code{x=l3};
\item \strong{numeric} column \code{x} is transformed according to \code{.method}:
\itemize{
\item \code{.method = "dummy"}: the column is treated as a factor with one level
for each unique value, then expanded to dummy columns. This produces
one logical column per unique value;
\item \code{.method = "crisp"}: the column is discretized into intervals (defined
by \code{.breaks}) and then expanded to dummy columns representing these
intervals;
\item \code{.method = "triangle"} or \code{.method = "raisedcos"}: the column is
converted into one or more fuzzy sets. Each new column contains values
in \eqn{[0,1]} representing degrees of membership to the fuzzy set
(triangular or raised-cosine shaped).
}
}

Details of numeric transformations are controlled by \code{.breaks}, \code{.labels},
\code{.right}, \code{.span}, and \code{.inc}.
\itemize{
\item Crisp partitioning is recommended for efficiency and works best when
sharp category boundaries are meaningful for the analysis.
\item Fuzzy partitioning is useful when attributes change gradually or when
uncertainty should be modeled explicitly. It allows smooth transitions
between categories and may yield more interpretable patterns, but is
more computationally demanding.
}
}
\section{Crisp transformation of numeric data}{


For \code{.method = "crisp"}, numeric columns are converted into sets of dummy
logical variables, each representing one interval of values defined by
\code{.breaks}.
\itemize{
\item If \code{.breaks} is an integer, it specifies the number of equal-width
intervals into which the column range is divided. The first and last
intervals extend to infinity.
\item If \code{.breaks} is a numeric vector, it specifies interval boundaries
directly. Infinite values are allowed.
}

With \code{.span = 1} and \code{.inc = 1}, the intervals are consecutive and
non-overlapping. For example, with
\code{.breaks = c(1, 3, 5, 7, 9, 11)} and \code{.right = TRUE},
the intervals are \eqn{(1;3]}, \eqn{(3;5]}, \eqn{(5;7]}, \eqn{(7;9]},
and \eqn{(9;11]}. If \code{.right = FALSE}, the intervals are left-closed:
\eqn{[1;3)}, \eqn{[3;5)}, etc.

Larger \code{.span} values make intervals overlap. For example, with
\code{.span = 2}, \code{.inc = 1}, and \code{.right = TRUE}, the intervals are
\eqn{(1;5]}, \eqn{(3;7]}, \eqn{(5;9]}, and \eqn{(7;11]}.

The \code{.inc} argument modifies how far the window shifts along \code{.breaks}.
For example:
\itemize{
\item \code{.span = 1}, \code{.inc = 2} → \eqn{(1;3]}, \eqn{(5;7]}, \eqn{(9;11]}.
\item \code{.span = 2}, \code{.inc = 3} → \eqn{(1;5]}, \eqn{(9;11]}.
}
}

\section{Fuzzy transformation of numeric data}{


For \code{.method = "triangle"} or \code{.method = "raisedcos"}, numeric columns are
converted into fuzzy membership degrees \eqn{[0,1]}.
\itemize{
\item If \code{.breaks} is an integer, it specifies the number of fuzzy sets to
generate (breakpoints are chosen automatically).
\item If \code{.breaks} is a numeric vector, it directly defines the fuzzy set
boundaries. Infinite values are allowed, which produces fuzzy sets with
open ends.
}

With \code{.span = 1}, each fuzzy set is defined by three consecutive breaks:
membership is 0 outside the outer breaks, increases to 1 at the middle
break, and then decreases back to 0. This yields triangular or raised-cosine
sets.

With \code{.span > 1}, fuzzy sets are defined by four breaks: the degree
increases between the first two, stays 1 between the middle two, and
decreases between the last two. This produces trapezoidal fuzzy sets, with
linear borders if \code{.method = "triangle"}, or cosine-shaped borders if
\code{.method = "raisedcos"}.

As with crisp sets, \code{.inc} determines how far the break window shifts when
creating the next fuzzy set. For example:
\itemize{
\item \code{.span = 1}, \code{.inc = 1} → \eqn{(1;3;5)}, \eqn{(3;5;7)}, \eqn{(5;7;9)}, \eqn{(7;9;11)}.
\item \code{.span = 2}, \code{.inc = 1} → \eqn{(1;3;5;7)}, \eqn{(3;5;7;9)}, \eqn{(5;7;9;11)}.
\item \code{.span = 1}, \code{.inc = 3} → \eqn{(1;3;5)}, \eqn{(7;9;11)}.
}

See the examples for further details.
}

\examples{
# Transform logical columns and factors
d <- data.frame(a = c(TRUE, TRUE, FALSE),
                b = factor(c("A", "B", "A")),
                c = c(1, 2, 3))
partition(d, a, b, c, .method = "dummy")

# Crisp transformation of numeric data
partition(CO2, conc:uptake, .method = "crisp", .breaks = 3)

# Triangular fuzzy sets
partition(CO2, conc:uptake, .method = "triangle", .breaks = 3)

# Raised-cosine fuzzy sets
partition(CO2, conc:uptake, .method = "raisedcos", .breaks = 3)

# Trapezoidal fuzzy sets, overlapping to satisfy the Ruspini condition
partition(CO2, conc:uptake, .method = "triangle", .breaks = 3,
          .span = 2, .inc = 2)

# Complex transformation with different settings per column
CO2 |>
  partition(Plant:Treatment) |>
  partition(conc,
            .method = "raisedcos",
            .breaks = c(-Inf, 95, 175, 350, 675, 1000, Inf)) |>
  partition(uptake,
            .method = "triangle",
            .breaks = c(-Inf, 7.7, 28.3, 45.5, Inf),
            .labels = c("low", "medium", "high"))

}
\author{
Michal Burda
}

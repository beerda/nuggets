---
title: "nuggets: Get Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nuggets: Get Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include=FALSE}
library(nuggets)
library(dplyr)
library(ggplot2)
library(tidyr)

options(tibble.width = Inf)
```


# Introduction

Package `nuggets` searches for patterns that can be expressed as formulae in
the form of elementary conjunctions, referred to in this text as *conditions*.
Conditions are constructed from *predicates*, which correspond to data
columns. The interpretation of conditions depends on the choice of underlying
logic:

- *Crisp (Boolean) logic*: each predicate takes values `TRUE` (1) or `FALSE`
  (0). The truth value of a condition is computed according to the rules of
  classical Boolean algebra.
  
- *Fuzzy logic*: each predicate is assigned a *truth degree* from the interval
  $[0, 1]$. The truth degree of a conjunction is then computed using a chosen
  *triangular norm (t-norm)*. The package supports three common t-norms, which
  are defined for predicates' truth degrees $a, b \in [0, 1]$ as follows:
  - *Gödel* (minimum) t-norm: $\min(a, b)$ ;
  - *Goguen* (product) t-norm: $a \cdot b$ ;
  - *Łukasiewicz* t-norm: $\max(0, a + b - 1)$ 
  
Before applying `nuggets`, data columns intended as predicates must be prepared
either by *dichotomization* (conversion into *dummy* logical variables) or by
transformation into *fuzzy sets*. The package provides functions for both
transformations. See the section [Data Preparation](#data-preparation)  below
for a quick overview, or the [Data Preparation](data-preparation.html) vignette 
for a comprehensive guide.

`nuggets` implements functions to search for pre-defined types of patterns or
to discover patterns of *user-defined* type. For example, the package provides:

- `dig_associations()` for association rules,
- `dig_baseline_contrasts()`, `dig_complement_contrasts()`, and
  `dig_paired_baseline_contrasts()` for various contrast patterns on numeric
  variables,
- `dig_correlations()` for conditional correlations. 

To provide custom evaluation functions for conditions and to search for
*user-defined* types of patterns, the package offers two general functions:

- `dig()` is a general function for searching arbitrary pattern types.
- `dig_grid()` is a wrapper around `dig()` for patterns defined by conditions
  and a pair of columns evaluated by a user-defined function.  

See the section [Pre-defined Patterns](#pre-defined-patterns) below for examples
and details on using the pre-defined pattern discovery functions and the section
[Advanced Use](#advanced-use) for examples of custom pattern discovery.

Discovered rules and patterns can be post-processed, visualized, and explored
interactively. That part is covered in the section [Post-processing and
Visualization](#postprocessing-and-visualization) below.




# Data Preparation

Before applying `nuggets`, data columns intended as predicates must be prepared
either by *dichotomization* (conversion into *dummy variables*) or by
transformation into *fuzzy sets*. The package provides the `partition()` 
function for both transformations. 

This section gives a quick overview of data preparation with `nuggets`. For
a detailed guide, including information about all available functions and
advanced techniques, please see the  [Data Preparation](data-preparation.html)
vignette.


## Crisp (Boolean) Predicates Example

For crisp patterns, numeric columns are transformed to logical (`TRUE`/`FALSE`)
columns. To show the process, we start with the built-in `mtcars` dataset,
which we first slightly modify by converting the `cyl` column to a factor:

```{r}
# For demonstration, convert 'cyl' column of the mtcars dataset to a factor
mtcars <- mtcars |>
    mutate(cyl = factor(cyl, levels = c(4, 6, 8), labels = c("four", "six", "eight")))
```

Now we can use the `partition()` function to transform all columns into crisp
predicates:

```{r}
# Transform the whole dataset to crisp predicates
crisp_mtcars <- mtcars |>
    partition(cyl, vs:gear, .method = "dummy") |>
    partition(mpg, .method = "crisp", .breaks = c(-Inf, 15, 20, 30, Inf)) |>
    partition(disp:carb, .method = "crisp", .breaks = 3) 

head(crisp_mtcars, n = 3)
```

As seen above, the `"dummy"` method can be used to create logical columns for
each category of processed variables. Here, it was applied to create dummy
variables for the factor variable `cyl` as well as for the numeric variables
`vs`, `am`, and `gear`.

The method `"crisp"` creates logical columns representing intervals for
numeric variables. In the example, it was used to create intervals for `mpg`
based on specified breakpoints (`-Inf`, `15`, `20`, `30`, `Inf`), and for
`disp`, `hp`, `drat`, `wt`, `qsec`, and `carb` using equal-width intervals
(3 intervals each).

Now all columns are logical and can be used as predicates in crisp conditions.


## Fuzzy Predicates Example

Fuzzy predicates express the degree to which a condition is satisfied, with
values in the interval $[0,1]$. This allows modeling of smooth transitions
between categories:

```{r, message=FALSE}
# Start with fresh mtcars and transform to fuzzy predicates
fuzzy_mtcars <- mtcars |>
    partition(cyl, vs:gear, .method = "dummy") |>
    partition(mpg, .method = "triangle", .breaks = c(-Inf, 15, 20, 30, Inf)) |>
    partition(disp:carb, .method = "triangle", .breaks = 3) 

head(fuzzy_mtcars, n = 3)
```

Note that the `cyl`, `vs`, `am`, and `gear` columns are still represented by
dummy logical columns, while the numeric columns are now represented by fuzzy
sets. This combination allows both crisp and fuzzy predicates to be used 
together in pattern discovery.


## Advanced Data Preparation Capabilities

The `nuggets` package provides powerful and flexible data preparation tools. 
The [Data Preparation](data-preparation.html) vignette covers these capabilities 
in depth, including:

- **Crisp (Boolean) partitioning** with customizable interval strategies:
  - Equal-width intervals for uniform discretization
  - Data-driven methods (quantile, k-means, hierarchical clustering, etc.) for 
    optimal breakpoints that respect the data structure
  - Custom breakpoints for domain-specific intervals
  
- **Fuzzy partitioning** for modeling gradual transitions and uncertainty:
  - Triangular membership functions for basic fuzzy sets
  - Raised-cosine membership functions for smoother transitions
  - Trapezoidal shapes using `.span` and `.inc` parameters for overlapping 
    fuzzy sets
  
- **Quality control utilities** to improve pattern mining:
  - `is_almost_constant()` and `remove_almost_constant()` to identify and 
    filter uninformative columns
  - `dig_tautologies()` to find always-true rules that can be used to prune 
    search spaces
  
- **Custom labels** for predicates to make discovered patterns more interpretable

For example, you can use quantile-based partitioning to ensure balanced 
predicates, or use raised-cosine fuzzy sets with custom labels to create 
meaningful linguistic terms like "very_low", "low", "medium", "high", and 
"very_high". These preparation choices significantly impact the interpretability 
and usefulness of patterns discovered in subsequent analyses.




# Pre-defined Patterns

The package `nuggets` provides a set of functions for discovering some of the
best-known pattern types. These functions can process Boolean data, fuzzy data,
or both. Each function returns a tibble, where every row represents one detected
pattern.

> **Note:** This section assumes that the data have already been **preprocessed**
> — i.e., transformed into a binarized or fuzzified form. See the previous
> section [Data Preparation](#data-preparation) for details on how to prepare
> your dataset (for example, `crisp_mtcars` and `fuzzy_mtcars`).

For more advanced workflows — such as defining custom pattern types or
computing user-defined measures — see the section
[Advanced Use](#advanced-use).


## Search for Association Rules

**Association rules** identify conditions (*antecedents*) under which a specific
feature (*consequent*) is present very often.

\[
A \Rightarrow C
\]

If condition `A` is satisfied, then the feature `C` tends to be present.

For example,  
`university_edu & middle_age & IT_industry => high_income`  
can be read as:  
*People in middle age with university education working in IT industry are very
likely to have a high income.*

In practice, the antecedent `A` is a set of predicates, and the consequent `C`
is usually a single predicate.

For a set of predicates \(I\), let \(\text{supp}(I)\) denote the *support* —
the relative frequency (for logical data) or the mean truth degree (for fuzzy
data) of rows satisfying all predicates in \(I\). Using this notation:

- **Length** — number of predicates in the antecedent.  
- **Coverage** — \(\text{supp}(A)\).  
- **Consequent support** — \(\text{supp}(\{c\})\).  
- **Support** — \(\text{supp}(A \cup \{c\})\).  
- **Confidence** — \(\text{supp}(A \cup \{c\}) / \text{supp}(A)\).

Optional additional measures (`"lift"`, `"conviction"`, `"added_value"`) can be
computed using the `measures` argument.

Before searching for rules, it is recommended to create a *vector of disjoints*,
which specifies predicates that must not appear together in the same condition.
This vector should have the same length as the number of dataset columns.

For example, columns representing `gear=3` and `gear=4` are mutually exclusive,
so their shared group label in `disj` prevents meaningless conditions like
`gear=3 & gear=4`. You can conveniently generate this vector with
`var_names()`:

```{r}
disj <- var_names(colnames(fuzzy_mtcars))
print(disj)
```

The `dig_associations()` function searches for association rules. Its main
arguments are:

- `x`: the data matrix or data frame (logical or numeric);
- `antecedent`, `consequent`: tidyselect expressions selecting columns for each
  side of the rule;
- `disjoint`: a vector defining mutually exclusive predicates;
- rule filtering thresholds such as `min_support`, `min_confidence`,
  `min_coverage`, and limits like `min_length`, `max_length`;
- optional parameters such as `measures`, `t_norm`, and `contingency_table`.

In the following example, we search for fuzzy association rules in the dataset
`fuzzy_mtcars`, such that:
- any column except those starting with `"am"` may appear in the antecedent;
- columns starting with `"am"` may appear in the consequent;
- minimum support is `0.02`;
- minimum confidence is `0.8`;
- additional quality measures `"lift"` and `"conviction"` are computed.

```{r}
result <- dig_associations(fuzzy_mtcars,
                           antecedent = !starts_with("am"),
                           consequent = starts_with("am"),
                           disjoint = disj,
                           min_support = 0.02,
                           min_confidence = 0.8,
                           measures = c("lift", "conviction"),
                           contingency_table = TRUE)
```

The result is a tibble containing the discovered rules and their quality
metrics. You can arrange them, for example, by decreasing support:

```{r}
result <- arrange(result, desc(support))
print(result)
```

This example illustrates the typical workflow for mining association rules with
`nuggets`. The same structure and arguments apply when analyzing either fuzzy or
Boolean datasets.



## Conditional Correlations

**Conditional correlations** identify strong relationships between pairs of 
numeric variables under specific conditions.

The `dig_correlations()` function searches for pairs of variables that are 
significantly correlated within sub-data satisfying generated conditions. This 
is useful for discovering context-dependent relationships.

In the following example, we search for correlations between different numeric
variables in the original `mtcars` data under conditions defined by the prepared
predicates in `crisp_mtcars`:

```{r}
# Prepare combined dataset with both condition predicates and numeric variables
combined_mtcars <- cbind(crisp_mtcars, mtcars[, c("mpg", "disp", "hp", "wt")])

# Extend disjoint vector for the new numeric columns
disj_combined <- c(var_names(colnames(crisp_mtcars)),
                   c("mpg", "disp", "hp", "wt"))

# Search for conditional correlations
corr_result <- dig_correlations(combined_mtcars,
                                condition = colnames(crisp_mtcars),
                                xvars = c("mpg", "hp"),
                                yvars = c("wt", "disp"),
                                disjoint = disj_combined,
                                min_length = 1,
                                max_length = 2,
                                min_support = 0.2,
                                method = "pearson")

# Display results with strong correlations
print(corr_result)
```

The result shows conditions under which specific pairs of variables exhibit 
strong correlations, along with correlation coefficients and p-values.


## Contrast Patterns

Contrast patterns identify conditions under which numeric variables show 
statistically significant differences. The `nuggets` package provides several 
functions for different types of contrasts.


### Baseline Contrasts

**Baseline contrasts** identify conditions under which a variable is 
significantly different from a baseline value (typically zero) using a 
one-sample statistical test.

```{r}
# Prepare combined dataset with predicates and numeric variables
combined_mtcars2 <- cbind(crisp_mtcars, 
                          mtcars[, c("mpg", "hp", "wt")])

# Extend disjoint vector for the new numeric columns
disj_combined2 <- c(var_names(colnames(crisp_mtcars)),
                    c("mpg", "hp", "wt"))

# Search for baseline contrasts
baseline_result <- dig_baseline_contrasts(combined_mtcars2,
                                         condition = colnames(crisp_mtcars),
                                         vars = c("mpg", "hp", "wt"),
                                         disjoint = disj_combined2,
                                         min_length = 1,
                                         max_length = 2,
                                         min_support = 0.2,
                                         method = "t")

# Show top results
head(baseline_result)
```


### Complement Contrasts

**Complement contrasts** identify conditions under which a variable differs 
significantly between elements that satisfy the condition and those that don't.

```{r}
# Search for complement contrasts
complement_result <- dig_complement_contrasts(combined_mtcars2,
                                             condition = colnames(crisp_mtcars),
                                             vars = c("mpg", "hp", "wt"),
                                             disjoint = disj_combined2,
                                             min_length = 1,
                                             max_length = 2,
                                             min_support = 0.15,
                                             method = "t")

# Show top results
head(complement_result)
```


### Paired Baseline Contrasts

**Paired baseline contrasts** identify conditions under which there is a 
significant difference between two paired numeric variables.

```{r}
# Search for paired baseline contrasts
paired_result <- dig_paired_baseline_contrasts(combined_mtcars2,
                                              condition = colnames(crisp_mtcars),
                                              xvars = c("mpg", "hp"),
                                              yvars = c("wt", "wt"),
                                              disjoint = disj_combined2,
                                              min_length = 1,
                                              max_length = 2,
                                              min_support = 0.2,
                                              method = "t")

# Show top results
head(paired_result)
```


# Post-processing and Visualization

After discovering patterns with `nuggets`, you'll often want to manipulate, format, and visualize the results. The package provides several tools for these tasks.


## Working with Conditions

The `nuggets` package provides functions for manipulating condition strings:

### Formatting Conditions

The `format_condition()` function converts a vector of predicate names into a standardized string representation:

```{r, eval=FALSE}
# Format predicates into condition strings
format_condition(c("mpg=high", "cyl=4", "am=1"))
# Returns: "{am=1,cyl=4,mpg=high}"

format_condition(NULL)
# Returns: "{}" (empty condition, always true)
```

### Parsing Conditions

The `parse_condition()` function converts condition strings back into lists of predicates:

```{r, eval=FALSE}
# Parse condition strings
parse_condition(c("{mpg=high,cyl=4}", "{am=1}", "{}"))
# Returns a list of character vectors

# Merge conditions from multiple sources
parse_condition(c("{a,b}", "{x,y}"), c("{c}", "{z}"))
```

### Shortening Conditions

The `shorten_condition()` function abbreviates long predicate names for better visualization:

```{r, eval=FALSE}
# Shorten using letters
shorten_condition(c("{mpg=high,cyl=four,am=automatic}", 
                    "{mpg=low,hp=high}"),
                  method = "letters")
# Returns: "{A,B,C}", "{D,E}"

# Shorten using abbreviations
shorten_condition(c("{mpg=high,cyl=four}", "{mpg=low}"),
                  method = "abbrev4")
# Returns: "{cyl=,mpg=}", "{mpg=}"
```


## Visualizing Association Rules with Diamond Plots

The `geom_diamond()` function provides a specialized visualization for association
rules and their hierarchical structure. It displays rules as a lattice where 
broader (more general) conditions appear above their descendants:

```{r, fig.width=8, fig.height=5}
# Search for rules with various confidence levels for visualization
vis_rules <- dig_associations(fuzzy_mtcars,
                              antecedent = starts_with("mpg") | starts_with("disp"),
                              consequent = starts_with("am"),
                              disjoint = disj,
                              min_support = 0.01,
                              min_confidence = 0.6,
                              min_length = 0,
                              max_length = 3,
                              max_results = 50)

# Create diamond plot showing rule hierarchy
ggplot(vis_rules) +
    aes(condition = antecedent,
        fill = confidence,
        linewidth = confidence,
        size = support,
        label = shorten_condition(antecedent)) +
    geom_diamond(nudge_y = 0.25) +
    scale_fill_gradient(low = "lightblue", high = "darkblue") +
    labs(title = "Association Rules Hierarchy",
         subtitle = "Node size = support, color/edge width = confidence")
```

The diamond plot helps identify:
- Simple vs. complex rules (vertical position)
- Strong vs. weak rules (color intensity)
- Frequent vs. rare rules (node size)


## Interactive Exploration

The `explore()` function launches an interactive Shiny application for exploring 
discovered patterns. This is particularly useful for association rules:

```{r, eval=FALSE}
# Launch interactive explorer for association rules
rules <- dig_associations(fuzzy_mtcars,
                         antecedent = everything(),
                         consequent = everything(),
                         min_support = 0.05,
                         min_confidence = 0.7)

# Open interactive explorer
explore(rules, data = fuzzy_mtcars)
```

The interactive explorer provides:
- **Rule filtering**: Filter rules by support, confidence, lift, and other measures
- **Sorting and searching**: Find specific rules of interest
- **Visualizations**: Multiple visualization types for rule exploration
- **Data inspection**: Examine data records that satisfy specific rules



# Advanced Use

For advanced workflows, the `nuggets` package allows users to define custom 
pattern types and evaluation functions. This section demonstrates how to use 
the general `dig()` function with custom callbacks and the specialized 
`dig_grid()` wrapper.


## Custom Patterns with dig()

The `dig()` function allows you to execute a user-defined callback function on 
each generated frequent condition. This enables searching for custom pattern 
types beyond the pre-defined functions.

The following example replicates the search for association rules using a custom 
callback function with the datasets prepared earlier:

```{r}
# Define thresholds for custom association rules
min_support <- 0.02
min_confidence <- 0.8

# Define custom callback function
f <- function(condition, support, pp, pn) {
    # Calculate confidence for each focus (consequent)
    conf <- pp / support
    
    # Filter rules by confidence and support thresholds
    sel <- !is.na(conf) & conf >= min_confidence & !is.na(pp) & pp >= min_support
    conf <- conf[sel]
    supp <- pp[sel]
    
    # Return list of rules meeting criteria
    lapply(seq_along(conf), function(i) { 
      list(antecedent = format_condition(names(condition)),
           consequent = names(conf)[[i]],
           support = supp[[i]],
           confidence = conf[[i]])
    })
}

# Search using custom callback
custom_result <- dig(fuzzy_mtcars,
                    f = f,
                    condition = !starts_with("am"),
                    focus = starts_with("am"),
                    disjoint = disj,
                    min_length = 1,
                    min_support = min_support)

# Flatten and format results
custom_result <- custom_result |>
  unlist(recursive = FALSE) |>
  lapply(as_tibble) |>
  do.call(rbind, args = _) |>
  arrange(desc(support))

print(custom_result)
```

The callback function `f()` receives information based on its argument names:
- `condition`: vector of column indices forming the condition
- `support`: relative frequency of the condition
- `pp`, `pn`: contingency table entries for condition and foci

This approach gives you full control over pattern evaluation and filtering logic.


## Grid-Based Patterns with dig_grid()

The `dig_grid()` function is useful for patterns based on relationships between 
pairs of columns. It creates a grid of column combinations and evaluates a 
user-defined function for each condition and column pair.

Here's an example that computes custom statistics for pairs of numeric variables:

```{r}
# Define callback for grid-based patterns
grid_callback <- function(d, weights) {
    if (nrow(d) < 5) return(NULL)  # Skip if too few observations
    
    # Compute weighted correlation
    wcor <- cov.wt(d, wt = weights, cor = TRUE)$cor[1, 2]
    
    list(
        correlation = wcor,
        n_obs = sum(weights > 0.1),
        mean_x = weighted.mean(d[[1]], weights),
        mean_y = weighted.mean(d[[2]], weights)
    )
}

# Prepare combined dataset
combined_fuzzy <- cbind(fuzzy_mtcars, mtcars[, c("mpg", "hp", "wt")])

# Extend disjoint vector for new numeric columns
combined_disj3 <- c(var_names(colnames(fuzzy_mtcars)),
                    c("mpg", "hp", "wt"))

# Search using grid approach
grid_result <- dig_grid(combined_fuzzy,
                       f = grid_callback,
                       condition = colnames(fuzzy_mtcars),
                       xvars = c("mpg", "hp"),
                       yvars = c("wt"),
                       disjoint = combined_disj3,
                       type = "fuzzy",
                       min_length = 1,
                       max_length = 2,
                       min_support = 0.15,
                       max_results = 20)

# Display results
print(grid_result)
```

The `dig_grid()` function is particularly useful for:
- Computing conditional correlations with custom methods
- Evaluating pairwise relationships under different conditions
- Implementing specialized statistical tests on variable pairs
